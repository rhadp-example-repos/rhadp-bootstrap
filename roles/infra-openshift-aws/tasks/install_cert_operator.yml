# Implement your install deployment tasks here
# -------------------------------------------------

- name: create cert-manager namespace
  k8s:
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: "{{ cert_manager_namespace }}"
    state: present
    apply: yes
    kubeconfig: "{{ local_kubeconfig_file }}"

- name: create AWS credentials secret 1
  k8s:
    definition:
      apiVersion: v1
      kind: Secret
      metadata:
        name: route53-credentials
        namespace: "{{ cert_manager_namespace }}"
      type: Opaque
      data:
        access-key-id: "{{ aws_access_key_id | b64encode }}"
        secret-access-key: "{{ aws_secret_access_key | b64encode }}"
    state: present
    apply: yes
    kubeconfig: "{{ local_kubeconfig_file }}"

- name: create AWS credentials secret 2
  k8s:
    definition:
      apiVersion: v1
      kind: Secret
      metadata:
        name: route53-credentials
        namespace: "openshift-ingress"
      type: Opaque
      data:
        access-key-id: "{{ aws_access_key_id | b64encode }}"
        secret-access-key: "{{ aws_secret_access_key | b64encode }}"
    state: present
    apply: yes
    kubeconfig: "{{ local_kubeconfig_file }}"

- name: create cert-manager operator subscription
  k8s:
    definition:
      apiVersion: operators.coreos.com/v1alpha1
      kind: Subscription
      metadata:
        name: openshift-cert-manager-operator
        namespace: "{{ cert_manager_namespace }}"
      spec:
        channel: stable-v1
        installPlanApproval: Automatic
        name: openshift-cert-manager-operator
        source: redhat-operators
        sourceNamespace: openshift-marketplace
    state: present
    apply: yes
    kubeconfig: "{{ local_kubeconfig_file }}"

- name: create cert-manager instance
  k8s:
    definition:
      apiVersion: operator.openshift.io/v1alpha1
      kind: CertManager
      metadata:
        name: cluster
      spec:
        managementState: "Managed"
        logLevel: Normal
        operatorLogLevel: Normal
        unsupportedConfigOverrides:
          controller:
            args:
              - '--dns01-recursive-nameservers=1.1.1.1:53'
              - '--dns01-recursive-nameservers-only'
    state: present
    apply: yes
    kubeconfig: "{{ local_kubeconfig_file }}"

- name: wait for cert-manager operator to be ready
  k8s_info:
    api_version: v1
    kind: Deployment
    name: "{{ cert_manager_deployment_name }}"
    namespace: "{{ cert_manager_namespace }}"
    kubeconfig: "{{ local_kubeconfig_file }}"
  register: r_deployment
  retries: 60
  delay: 10
  until:
    - r_deployment.resources | length | int > 0
    - r_deployment.resources[0].spec.replicas is defined
    - r_deployment.resources[0].status.availableReplicas is defined
    - r_deployment.resources[0].status.availableReplicas | int == r_deployment.resources[0].spec.replicas | int

#- name: create Let's Encrypt staging ClusterIssuer
#  k8s:
#    definition:
#      apiVersion: cert-manager.io/v1
#      kind: ClusterIssuer
#      metadata:
#        name: letsencrypt-staging
#      spec:
#        acme:
#          server: https://acme-staging-v02.api.letsencrypt.org/directory
#          email: "{{ letsencrypt_email }}"
#          privateKeySecretRef:
#            name: letsencrypt-staging
#          solvers:
#          - dns01:
#              route53:
#                region: "{{ aws_default_region }}"
#                hostedZoneID: "{{ cluster_public_zone_id }}"
#                accessKeyID: "{{ aws_access_key_id }}"
#                secretAccessKeySecretRef:
#                  name: route53-credentials
#                  key: secret-access-key
#            selector:
#              dnsZones:
#              - "{{ cluster_base_domain }}"
#    state: present
#    apply: yes
#    kubeconfig: "{{ local_kubeconfig_file }}"
    
- name: create Let's Encrypt prod ClusterIssuer
  k8s:
    definition:
      apiVersion: cert-manager.io/v1
      kind: ClusterIssuer
      metadata:
        name: letsencrypt-prod
      spec:
        acme:
          server: https://acme-v02.api.letsencrypt.org/directory
          email: "{{ letsencrypt_email }}"
          privateKeySecretRef:
            name: letsencrypt-prod
          solvers:
          - dns01:
              route53:
                region: "{{ aws_default_region }}"
                hostedZoneID: "{{ cluster_public_zone_id }}"
                accessKeyID: "{{ aws_access_key_id }}"
                secretAccessKeySecretRef:
                  name: route53-credentials
                  key: secret-access-key
            selector:
              dnsZones:
              - "{{ cluster_base_domain }}"
    state: present
    apply: yes
    kubeconfig: "{{ local_kubeconfig_file }}"

- name: create wildcard certificate for default ingress
  k8s:
    definition:
      apiVersion: cert-manager.io/v1
      kind: Certificate
      metadata:
        name: default-ingress-cert
        namespace: openshift-ingress
        annotations:
          cert-manager.io/revision-history-limit: "3"
      spec:
        secretName: default-ingress-cert
        secretTemplate:
          annotations:
            cert-manager.io/allow-direct-injection: "true"
          labels:
            cert-manager.io/certificate-name: default-ingress-cert
        issuerRef:
          name: letsencrypt-prod
          kind: ClusterIssuer
        dnsNames:
        - "*.apps.{{ cluster_name }}.{{ cluster_base_domain }}"
        - "apps.{{ cluster_name }}.{{ cluster_base_domain }}"
        duration: 2160h # 90 days
        renewBefore: 168h # 1 week
    state: present
    apply: yes
    kubeconfig: "{{ local_kubeconfig_file }}"
    
- name: wait for certificate to be ready
  k8s_info:
    api_version: cert-manager.io/v1
    kind: Certificate
    name: default-ingress-cert
    namespace: openshift-ingress
    kubeconfig: "{{ local_kubeconfig_file }}"
  register: r_certificate
  retries: 60
  delay: 10
  until:
    - r_certificate.resources | length | int > 0
    #- r_certificate.resources[0].status.conditions[0].type == "Issuing"
    #- r_certificate.resources[0].status.conditions[0].status == "True"
    
- name: configure ingress controller to use the certificate
  k8s:
    definition:
      apiVersion: operator.openshift.io/v1
      kind: IngressController
      metadata:
        name: default
        namespace: openshift-ingress-operator
      spec:
        defaultCertificate:
          name: default-ingress-cert
    state: present
    merge_type: merge
    kubeconfig: "{{ local_kubeconfig_file }}"